<!DOCTYPE html>
<html lang="en">

<!-- -----


 Be sure to set your API key in place of "YOUR_API_KEY"

----  -->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Maps Timeline</title>
    <script>
		(g=>{var h,a,k,p="The Google Maps JavaScript API",c="google",l="importLibrary",q="__ib__",m=document,b=window;b=b[c]||(b[c]={});var d=b.maps||(b.maps={}),r=new Set,e=new URLSearchParams,u=()=>h||(h=new Promise(async(f,n)=>{await (a=m.createElement("script"));e.set("libraries",[...r]+"");for(k in g)e.set(k.replace(/[A-Z]/g,t=>"_"+t[0].toLowerCase()),g[k]);e.set("callback",c+".maps."+q);a.src=`https://maps.${c}apis.com/maps/api/js?`+e;d[q]=f;a.onerror=()=>h=n(Error(p+" could not load."));a.nonce=m.querySelector("script[nonce]")?.nonce||"";m.head.append(a)}));d[l]?console.warn(p+" only loads once. Ignoring:",g):d[l]=(f,...n)=>r.add(f)&&u().then(()=>d[l](f,...n))})({
		key: "YOUR_API_KEY",
		v: "weekly",
		// Use the 'v' parameter to indicate the version to use (weekly, beta, alpha, etc.).
		// Add other bootstrap parameters as needed, using camel case.
		libraries: "marker,places"
		});
	</script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>


    <style>
        body, html {
            height: 100%;
            margin: 0;
            font-family: Arial, sans-serif;
        }
        #container {
            display: flex;
            height: 100%;
        }
        #sidebar {
            width: 330px;
            padding: 10px;
            overflow-y: auto;
            position: relative;
        }
		#datePickerContainer {
		  padding: 0px;
		  padding-top:12px;
		  background: white;
		  border-bottom: 1px solid #e0e0e0;
		  display: flex;
		  align-items: center;
		  justify-content: space-between;
		  gap: 8px;
		}
        #datePicker {
          flex: 1;
		  padding: 8px;
		  border: 1px solid #ddd;
		  border-radius: 4px;
		  font-size: 14px;
        }
		#prevDayBtn, #nextDayBtn {
		  background: #f8f9fa;
		  border: 1px solid #ddd;
		  border-radius: 4px;
		  padding: 4px 6px;
		  cursor: pointer;
		  font-size: 16px;
		  color: #555;
		  transition: all 0.2s ease;
		}

		#prevDayBtn:hover, nextDayBtn:hover {
		  background: #e9ecef;
		  color: #333;
		}
        #map {
            flex-grow: 1;
        }
        
        #controls-container {
		  padding: 10px;
		  border-bottom: 1px solid #e0e0e0;
		  display: flex;
		  align-items: center;
		  justify-content: center;
		  gap: 8px;
		}
		.control-btn {
		  flex-grow:1;
		  padding: 12px 20px;
		  background: #4285F4;
		  color: white;
		  border: none;
		  border-radius: 4px;
		  cursor: pointer;
		  font-size: 14px;
		  font-weight: 500;
		  transition: background-color 0.2s ease;
		}
		.control-btn:hover {
		  background: #3367d6;
		}
		.btn-icon {
		  font-size: 12px;
		}

        
        .timeline-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 5px;
            background-color: #f0f0f0;
            cursor: pointer;
            position: relative;
        }
        .timeline-icon-container {
            width: 32px;
            text-align: center;
            padding-right: 12px;
        }
        .place-visit-item {
            background-color: #fffacd;
            border: 1px solid #ffd700;
            padding-top: 10px;
            padding-bottom: 10px;
        }
        .highlighted {
            border: 2px solid #000;
        }
        /*.timeline-item::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 3px;
            height: 100%;
        }*/
        #timeline .date-header{
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 30px 10px 10px 10px;
            background-color: #fff;
            position: relative;
			font-weight: bold;
        }
        .confirmed-checkmark {
            position: absolute;
            bottom: 5px;
            right: 5px;
            font-size: 12px;
            opacity: 20%;
        }
        .highlighted .confirmed-checkmark{
            opacity: 35%;
        }
        .advanced-marker {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .marker-icon {
            font-size: 24px;
        }
        .marker-label {
            font-size: 12px;
            white-space: nowrap;
        }

        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 1000;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.2em;
        }

        #loading-spinner {
            border: 8px solid #f3f3f3;
            border-top: 8px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 2s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .layer-option {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .layer-checkbox {
            margin-right: 8px;
        }

        #layerOptions {
            padding: 10px;
            border-bottom: 1px solid #ccc;
        }

        #layerOptions h4 {
            margin-top: 0;
            margin-bottom: 10px;
        }

        #layerOptions label {
            display: block;
            margin-bottom: 5px;
        }
    </style>
</head>

<body>
    <div id="container">
        <div id="sidebar">
            <div id="controls-container">
                <button id="folderPicker" class="control-btn">Choose Folder</button>
                <button id="layerBtn" class="control-btn">Layers</button>
                <button id="goBtn" class="control-btn">GO</button>
            </div>
            <div id="layerOptions" style="display: none;">
                <h4>View Options</h4>
                <label>
                    <input type="checkbox" id="showVisits" class="layer-checkbox" checked> Show Visits
                </label>
                <label>
                    <input type="checkbox" id="showActivities" class="layer-checkbox" checked> Show Activities
                </label>
                <div id="activityFilters" style="margin-left: 20px;">
                </div>
            </div>
            <div id="datePickerContainer">
                <span id="prevDayBtn">&lt;</span>
                <input type="date" id="startDatePicker">
                <span>to</span>
                <input type="date" id="endDatePicker">
                <span id="nextDayBtn">&gt;</span>
            </div>
            <div id="loading-overlay">
                <div id="loading-spinner"></div>
                <span>Loading data...</span>
            </div>
            <div id="timeline"></div>
        </div>
        <div id="map"></div>
    </div>

    <script>
        let map;
        let markers = [];
        let polylines = [];
        let infoWindows = [];
        let selectedPolyline = null;
        let timelineData = {};
        let activityTypes = new Set(); // Keep track of unique activity types
        let placeDetailsCache = {}; // Cache for storing Place Details
        let globalIndex = 0; // Global counter for unique data-index


		// initMap is now async
		async function initMap() {
			// Request libraries when needed, not in the script tag.
			const { Map } = await google.maps.importLibrary("maps");
			// Short namespaces can be used.
			map = new Map(document.getElementById("map"), {
				center: { lat: 25.034170396411103, lng: 121.56456035320929 },
				zoom: 12,
				mapId: "TIMELINE_MAP"
			});
			const { AdvancedMarkerElement } = await google.maps.importLibrary("marker");
			const { PinElement } = await google.maps.importLibrary("marker");
		}

		function createTimelineItem(item, index, currentDate) {
			console.log('Creating timeline item:', item, 'with index:', index, 'and date:', currentDate);
			const timelineItem = document.createElement('div');
			timelineItem.className = 'timeline-item';
			timelineItem.dataset.index = index;

			// Check if a date header needs to be added
			if (!document.querySelector(`.date-header[data-date="${currentDate}"]`)) {
				const dateHeader = document.createElement('div');
				dateHeader.className = 'date-header';
				dateHeader.dataset.date = currentDate;
				dateHeader.textContent = moment(currentDate).format('dddd, MMMM DD, YYYY');
				document.getElementById('timeline').appendChild(dateHeader);
			}

			if (item.placeVisit) {
				const placeVisit = item.placeVisit;
				const locationName = placeVisit.location.name || (placeVisit.location.semanticType === "TYPE_HOME" ?
					"Home" : 'Unknown location');
				timelineItem.classList.add('place-visit-item');
				timelineItem.innerHTML = `
						<span class="timeline-icon-container">üìç</span>
						<div>
							<strong class="nametag">${locationName}</strong><br>
							${moment(placeVisit.duration.startTimestamp).format('hh:mm A')} -
							${moment(placeVisit.duration.endTimestamp).format('hh:mm A')}
						</div>
					`;
				timelineItem.style.setProperty('--activity-color', '#8B4513');
				console.log("createTimelineItem for index " + index + ", place is " + locationName);
			} else if (item.activitySegment) {
				const activitySegment = item.activitySegment;
				const distance = (activitySegment.distance || (activitySegment.simplifiedRawPath &&
					activitySegment.simplifiedRawPath.distanceMeters) || 0) / 1000;
				timelineItem.innerHTML = `
						<span class="timeline-icon-container">${getActivityIcon(activitySegment.activityType)}</span>
						<div>
							<strong>${formatActivityType(activitySegment.activityType)}</strong><br>
							${moment(activitySegment.duration.startTimestamp).format('hh:mm A')} -
							${moment(activitySegment.duration.endTimestamp).format('hh:mm A')}<br>
							Distance: ${distance.toFixed(2)} km
						</div>
					`;

				timelineItem.style.setProperty('--activity-color', getActivityColor(activitySegment.activityType));
				timelineItem.style.borderRight = `3px solid ${getActivityColor(activitySegment.activityType)}`;
			}

			if (item.placeVisit && item.placeVisit.editConfirmationStatus === "CONFIRMED" ||
				item.activitySegment && item.activitySegment.editConfirmationStatus === "CONFIRMED") {
				const checkmark = document.createElement('span');
				checkmark.className = 'confirmed-checkmark';
				checkmark.textContent = '‚úîÔ∏è';
				timelineItem.appendChild(checkmark);
			}
			return timelineItem;
		}

		async function loadTimelineDataForDate(selectedDate) {
			selectedDate.setMinutes(selectedDate.getMinutes() + selectedDate.getTimezoneOffset());
			const year = selectedDate.getFullYear();
			const month = selectedDate.toLocaleString('default', {
				month: 'long'
			}).toUpperCase();
			const dataKey = `${year}_${month}`;

			if (timelineData[dataKey]) {
				const selectedDateMoment = moment(selectedDate);
				const relevantData = timelineData[dataKey].timelineObjects.filter(item => {
					const itemStartTimestamp = moment(item.placeVisit ? item.placeVisit.duration
						.startTimestamp : item.activitySegment.duration.startTimestamp);
					const itemEndTimestamp = moment(item.placeVisit ? item.placeVisit.duration
						.endTimestamp : item.activitySegment.duration.endTimestamp);

					// Check if the item should be displayed based on layer visibility
					if (item.placeVisit && !document.getElementById('showVisits').checked) return false;
					if (item.activitySegment && !document.getElementById('showActivities').checked) return false;
					if (item.activitySegment) {
						const activityType = item.activitySegment.activityType;
						if (!document.getElementById(`filter-${activityType}`).checked) return false;
					}

					return itemStartTimestamp.isSameOrBefore(selectedDateMoment, 'day') && itemEndTimestamp
						.isSameOrAfter(selectedDateMoment, 'day');
				});

				let firstLocationSet = false;

				console.log('Relevant data for this date:', relevantData);

				relevantData.forEach((item, index) => {

					// Set the map center only once, based on the first valid item
					if (!firstLocationSet) {
						if (item.placeVisit) {
							const placeVisit = item.placeVisit;
							const latLng = {
								lat: placeVisit.location.latitudeE7 / 1e7,
								lng: placeVisit.location.longitudeE7 / 1e7
							};
							map.setCenter(latLng);
							map.setZoom(15);
							firstLocationSet = true;
						} else if (item.activitySegment) {
							const activitySegment = item.activitySegment;
							const startLatLng = {
								lat: activitySegment.startLocation.latitudeE7 / 1e7,
								lng: activitySegment.startLocation.longitudeE7 / 1e7
							};
							map.setCenter(startLatLng);
							map.setZoom(15);
							firstLocationSet = true;
						}
					}
				});

				relevantData.forEach((item, index) => {
					const currentDate = selectedDateMoment.format('YYYY-MM-DD'); // Get the formatted date
					const timelineItem = createTimelineItem(item, globalIndex, currentDate);
					document.getElementById('timeline').appendChild(timelineItem);
					console.log("loadTimelineDataForDate appended for index " + globalIndex + ".");

					if (item.placeVisit) {
						renderPlaceVisit(item.placeVisit, globalIndex);
					} else if (item.activitySegment) {
						renderActivitySegment(item.activitySegment, globalIndex);
					}

					globalIndex++;
				});
			} else {
				console.log('No data available for the selected date');
			}
		}

        async function loadTimelineDataInDateRange(startDate, endDate) {
            clearMap();
            clearSidebar();
            const currentDate = moment(startDate);
            while (currentDate.isSameOrBefore(endDate, 'day')) {
                await loadTimelineDataForDate(currentDate.toDate());
                currentDate.add(1, 'days');
            }
        }

        function clearMap() {
            markers.forEach(marker => marker.setMap(null));
            markers = [];
            polylines.forEach(polyline => polyline.setMap(null));
            polylines = [];
            infoWindows.forEach(infoWindow => infoWindow.close());
            infoWindows = [];
        }

        function clearSidebar() {
            const timeline = document.getElementById('timeline');
            timeline.innerHTML = '';
        }

		function renderPlaceVisit(placeVisit, index) {
			let locationName = placeVisit.location.name || 
							   (placeVisit.location.semanticType === "TYPE_HOME" ? "Home" : "Unknown Location");
			const placeId = placeVisit.location.placeId;
			console.log("renderPlaceVisit for index "+index+". place is "+locationName+", id is "+placeId);

			// Attempt to fetch Place Details if placeId exists
			if (placeId) {
				if (placeDetailsCache[placeId]) {
					console.log("Using cached details for: "+locationName+", id is "+placeId);
					renderPlaceDetails(placeDetailsCache[placeId], placeVisit, index);
				} else {
					fetchPlaceDetails(placeId, locationName, placeVisit, index);
				}
			} else {
				console.warn("No placeId available for placeVisit:", placeVisit);
				updateSidebarItem(index, locationName, null);
			}
		}

		function fetchPlaceDetails(placeId, fallbackName, placeVisit, index) {
			const placeService = new google.maps.places.PlacesService(map);
			const request = {
				placeId: placeId,
				fields: ["name", "formatted_address", "icon", "photos", "website"]
			};

			placeService.getDetails(request, (place, status) => {
				if (status === google.maps.places.PlacesServiceStatus.OK) {
					console.log("fetchPlaceDetails result for index: "+index+", id is "+placeId+". result:"+place);
				
					// Cache the result
					placeDetailsCache[placeId] = place;

					// Render details
					renderPlaceDetails(place, placeVisit, index);
				} else {
					console.error("Error fetching place details:", status, "for placeId:", placeId);
					updateSidebarItem(index, fallbackName, null);
				}
			});
		}

		function updateSidebarItem(index, locationName, iconUrl) {
			const sidebarItem = document.querySelector(`.timeline-item[data-index="${index}"]`);
			if (sidebarItem) {
				const nametag = sidebarItem.querySelector('.nametag');
				if (nametag) {
					nametag.textContent = locationName;
				}
				console.log("updateSidebarItem for index "+index+". place is "+locationName);

				const iconContainer = sidebarItem.querySelector('.timeline-icon-container');
				if (iconContainer && iconUrl) {
					iconContainer.innerHTML = `<img src="${iconUrl}" alt="${locationName}" style="width: 24px; height: 24px;">`;
				}
			} else {
				console.warn("Sidebar item not found for index:", index);
			}
		}


		function renderPlaceDetails(place, placeVisit, index) {
			var locationName = placeVisit.location.name || (placeVisit.location.semanticType === "TYPE_HOME" ? "Home" : 'Unknown Location');
			// Only update the name if it's not already set to something other than "Unknown Location"
			if (!placeVisit.location.name || placeVisit.location.name === "Unknown Location" || placeVisit.location.name === "Unknown location"){
				locationName = place.name;
			}
			console.log("renderPlaceDetails for index "+index+". place is "+locationName);
			
			const pinElement = new google.maps.marker.PinElement({
				background: place.icon_background_color,
				glyph: new URL(String(place.icon)),
			});

			const marker = new google.maps.marker.AdvancedMarkerElement({
				position: {
					lat: placeVisit.location.latitudeE7 / 1e7,
					lng: placeVisit.location.longitudeE7 / 1e7
				},
				map: map,
				content: pinElement.element,
				title: locationName,
			});

			markers.push(marker);

			const photoUrl = place.photos
				? place.photos[0].getUrl({
					maxWidth: 200,
					maxHeight: 200,
				})
				: "";
			const websiteLink = place.website
				? `<a href="${place.website}" target="_blank">Website</a><br>`
				: "";
			const infoWindowContent = `
				<h3>${locationName}</h3>
				<p>${place.formatted_address || "Address not available"}</p>
				${photoUrl
					? `<img src="${photoUrl}" alt="${locationName}" style="max-width: 200px; max-height: 200px;"><br>`
					: ""
				}
				<p>${moment(placeVisit.duration.startTimestamp).format(
					"YYYY-MM-DD hh:mm A"
				)} -
				${moment(placeVisit.duration.endTimestamp).format(
					"YYYY-MM-DD hh:mm A"
				)}</p>
				${websiteLink || ""}
				<p><a href="https://www.google.com/maps/place/?q=place_id:${placeVisit.location.placeId
				}" target="_blank">View on Google Maps</a></p>
			`;

			const infoWindow = new google.maps.InfoWindow({
				content: infoWindowContent,
			});
			infoWindows.push(infoWindow);

			const sidebarItem = document.querySelector(
				`.timeline-item[data-index="${index}"]`
			);
			if (sidebarItem) {
				const iconContainer =
					sidebarItem.querySelector(".timeline-icon-container");
				const nametag = sidebarItem.querySelector(".nametag");

				if (nametag) {
					iconContainer.innerHTML = `<img src="${place.icon}" alt="${locationName}" style="width: 24px; height: 24px;">`;
					nametag.innerHTML = `${locationName}`;
				} else {
					console.warn("Nametag element not found for place:", locationName);
				}
			} else {
				console.warn(
					`Sidebar item not found for place with index ${index}:`,
					locationName
				);
			}

			addMarkerClickListener(marker, infoWindow, index);
			addSidebarItemClickListener(sidebarItem, index, marker, infoWindow);
		}

        function renderActivitySegment(activitySegment, index) {
			console.log("renderActivitySegment for index "+index+". segment is "+activitySegment);
            let path = [];

            // Start by adding the start location to the path
            path.push({
                lat: activitySegment.startLocation.latitudeE7 / 1e7,
                lng: activitySegment.startLocation.longitudeE7 / 1e7
            });

            // Add the detailed path points, giving priority to the most detailed available
            if (activitySegment.simplifiedRawPath && activitySegment.simplifiedRawPath.points) {
                path = path.concat(activitySegment.simplifiedRawPath.points.map(point => ({
                    lat: point.latE7 / 1e7,
                    lng: point.lngE7 / 1e7
                })));
            } else if (activitySegment.timelinePath && activitySegment.timelinePath.points) {
                path = path.concat(activitySegment.timelinePath.points.map(point => ({
                    lat: point.latE7 / 1e7,
                    lng: point.lngE7 / 1e7
                })));
            } else if (activitySegment.waypointPath && activitySegment.waypointPath.waypoints) {
                path = path.concat(activitySegment.waypointPath.waypoints.map(point => ({
                    lat: point.latE7 / 1e7,
                    lng: point.lngE7 / 1e7
                })));
            }

            // Add the end location to the path
            path.push({
                lat: activitySegment.endLocation.latitudeE7 / 1e7,
                lng: activitySegment.endLocation.longitudeE7 / 1e7
            });

            // Define a line symbol to add arrows to the polyline
            const lineSymbol = {
                path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
            };

            // Create a polyline on the map
            const polyline = new google.maps.Polyline({
                path: path,
                geodesic: true,
                strokeColor: getActivityColor(activitySegment.activityType),
                strokeOpacity: 1.0,
                strokeWeight: 5,
                map: map
            });

            // Store the polyline so it can be cleared later if needed
            polylines.push(polyline);

            // Find the corresponding sidebar item
            const sidebarItem = document.querySelector(`.timeline-item[data-index="${index}"]`);

            // Add event listeners for user interaction
            addPolylineClickListener(polyline, sidebarItem, path);
            addSidebarItemClickListener(sidebarItem, index, null, polyline, path);
        }


        function addMarkerClickListener(marker, infoWindow, index) {
			marker.addListener('click', () => {
				infoWindows.forEach(iw => iw.close());
				infoWindow.open(map, marker);
				highlightSidebarItem(index);

				if (selectedPolyline) {
					selectedPolyline.setOptions({
						icons: []
					});
					selectedPolyline = null;
				}
			});
		}

        function addPolylineClickListener(polyline, timelineItem, path) {
            polyline.addListener('click', () => {
                highlightSidebarItem(timelineItem.dataset.index);
                const bounds = new google.maps.LatLngBounds();
                path.forEach(point => bounds.extend(point));
                map.fitBounds(bounds);

                if (selectedPolyline) {
                    selectedPolyline.setOptions({
                        icons: []
                    });
                }

                polyline.setOptions({
                    icons: [{
                        icon: {
                            path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
                            scale: 4
                        },
                        offset: '50%',
                        repeat: '80px'
                    }],
                });

                selectedPolyline = polyline;

                // Close all info windows
                infoWindows.forEach(iw => iw.close());

                timelineItem.scrollIntoView({
                    behavior: 'smooth',
                    block: 'nearest'
                });
            });
        }

		function addSidebarItemClickListener(sidebarItem, index, marker, infoWindow, polyline, path) {
			sidebarItem.addEventListener('click', () => {
				if (marker && infoWindow) {
					map.setCenter(marker.position);
					map.setZoom(15);
					infoWindows.forEach(iw => iw.close());
					infoWindow.open(map, marker);
				} else if (polyline && path) {
					const bounds = new google.maps.LatLngBounds();
					path.forEach(point => bounds.extend(point));
					map.fitBounds(bounds);

					if (selectedPolyline) {
						selectedPolyline.setOptions({
							icons: []
						});
					}

					polyline.setOptions({
						icons: [{
							icon: {
								path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
								scale: 4
							},
							offset: '50%',
							repeat: '80px'
						}],
					});

					selectedPolyline = polyline;
				}

				highlightSidebarItem(index);
			});
		}
		
        function highlightSidebarItem(index) {
			console.log("highlightSidebarItem for index "+index);
			const timelineItems = document.querySelectorAll('.timeline-item');
			timelineItems.forEach((timelineItem) => {
				if (timelineItem.dataset.index === index.toString()) {
					timelineItem.classList.add('highlighted');
					timelineItem.scrollIntoView({
						behavior: 'smooth',
						block: 'nearest'
					});
				} else {
					timelineItem.classList.remove('highlighted');
				}
			});
		}

        function getActivityIcon(activityType) {
            switch (activityType) {
                case 'IN_VEHICLE':
                case 'IN_PASSENGER_VEHICLE':
                case 'IN_TAXI':
                    return 'üöó';
                case 'ON_BICYCLE':
                case 'CYCLING':
                    return 'üö¥';
                case 'ON_FOOT':
                case 'WALKING':
                case 'WALKING_NORDIC':
                    return 'üö∂';
                case 'STILL':
                    return 'üõë';
                case 'UNKNOWN':
                case 'UNKNOWN_ACTIVITY_TYPE':
                    return '‚ùì';
                case 'TILTING':
                    return 'üì±';
                case 'RUNNING':
                    return 'üèÉ';
                case 'FLYING':
                    return '‚úàÔ∏è';
                case 'IN_BUS':
                    return 'üöå';
                case 'IN_SUBWAY':
                    return 'üöá';
                case 'IN_TRAIN':
                    return 'üöÜ';
                case 'IN_TRAM':
                    return 'üöä';
                case 'IN_CABLECAR':
                    return 'üö†';
                case 'IN_FERRY':
                    return '‚õ¥Ô∏è';
                case 'IN_FUNICULAR':
                    return 'üöû';
                case 'IN_GONDOLA_LIFT':
                    return 'üö°';
                case 'IN_WHEELCHAIR':
                    return '‚ôø';
                case 'BOATING':
                    return 'üö§';
                case 'CATCHING_POKEMON':
                    return 'üéÆ';
                case 'HIKING':
                    return 'ü•æ';
                case 'HORSEBACK_RIDING':
                    return 'üêé';
                case 'KAYAKING':
                    return 'üõ∂';
                case 'KITESURFING':
                    return 'üèÑ‚Äç‚ôÇÔ∏è';
                case 'MOTORCYCLING':
                    return 'üèçÔ∏è';
                case 'PARAGLIDING':
                    return 'ü™Ç';
                case 'ROWING':
                    return 'üö£';
                case 'SAILING':
                    return '‚õµ';
                case 'SKATEBOARDING':
                    return 'üõπ';
                case 'SKATING':
                    return '‚õ∏Ô∏è';
                case 'SKIING':
                    return '‚õ∑Ô∏è';
                case 'SLEDDING':
                    return 'üõ∑';
                case 'SNOWBOARDING':
                    return 'üèÇ';
                case 'SNOWMOBILE':
                    return 'üöú';
                case 'SNOWSHOEING':
                    return '‚ùÑÔ∏è';
                case 'SURFING':
                    return 'üèÑ';
                case 'SWIMMING':
                    return 'üèä';
                default:
                    return '‚ùì';
            }
        }

        function getActivityColor(activityType) {
            switch (activityType) {
                case 'ON_FOOT':
                case 'WALKING':
                case 'RUNNING':
                case 'ON_BICYCLE':
                case 'CYCLING':
                    return '#FF0000'; // Red
                case 'IN_VEHICLE':
                case 'IN_PASSENGER_VEHICLE':
                case 'IN_TAXI':
                    return '#0000FF'; // Blue
                case 'IN_SUBWAY':
                    return '#006400'; // Dark Green
                case 'IN_BUS':
                    return '#800080'; // Purple
                default:
                    return '#8B4513'; // Brown
            }
        }

        function formatActivityType(activityType) {
            switch (activityType) {
                case 'IN_VEHICLE':
                case 'IN_PASSENGER_VEHICLE':
                    return 'In a Vehicle';
                case 'ON_BICYCLE':
                case 'CYCLING':
                    return 'On a Bicycle';
                case 'ON_FOOT':
                    return 'On Foot';
                case 'STILL':
                    return 'Still';
                case 'UNKNOWN':
                case 'UNKNOWN_ACTIVITY_TYPE':
                    return 'Unknown Travel';
                case 'TILTING':
                    return 'Tilting';
                case 'WALKING':
                    return 'Walking';
                case 'WALKING_NORDIC':
                    return 'Nordic Walking';
                case 'RUNNING':
                    return 'Running';
                case 'FLYING':
                    return 'Flying';
                case 'IN_BUS':
                    return 'On a Bus';
                case 'IN_SUBWAY':
                    return 'On the Subway';
                case 'IN_TRAIN':
                    return 'On a Train';
                case 'IN_TRAM':
                    return 'On a Tram';
                case 'IN_CABLECAR':
                    return 'In a Cable Car';
                case 'IN_FERRY':
                    return 'On a Ferry';
                case 'IN_FUNICULAR':
                    return 'On a Funicular';
                case 'IN_GONDOLA_LIFT':
                    return 'In a Gondola Lift';
                case 'IN_WHEELCHAIR':
                    return 'By Wheelchair';
                case 'BOATING':
                    return 'Boating';
                case 'CATCHING_POKEMON':
                    return 'Catching Pok√©mon';
                case 'HIKING':
                    return 'Hiking';
                case 'HORSEBACK_RIDING':
                    return 'Horseback Riding';
                case 'KAYAKING':
                    return 'Kayaking';
                case 'KITESURFING':
                    return 'Kitesurfing';
                case 'MOTORCYCLING':
                    return 'Motorcycling';
                case 'PARAGLIDING':
                    return 'Paragliding';
                case 'ROWING':
                    return 'Rowing';
                case 'SAILING':
                    return 'Sailing';
                case 'SKATEBOARDING':
                    return 'Skateboarding';
                case 'SKATING':
                    return 'Skating';
                case 'SKIING':
                    return 'Skiing';
                case 'SLEDDING':
                    return 'Sledding';
                case 'SNOWBOARDING':
                    return 'Snowboarding';
                case 'SNOWMOBILE':
                    return 'Snowmobiling';
                case 'SNOWSHOEING':
                    return 'Snowshoeing';
                case 'SURFING':
                    return 'Surfing';
                case 'SWIMMING':
                    return 'Swimming';
                default:
                    return 'Unknown';
            }
        }

        function initDatePicker() {
            const startDatePicker = document.getElementById('startDatePicker');
            const endDatePicker = document.getElementById('endDatePicker');

            startDatePicker.value = moment().subtract(7, 'days').format('YYYY-MM-DD');
            endDatePicker.value = moment().format('YYYY-MM-DD');

            document.getElementById('prevDayBtn').addEventListener('click', () => {
                const startDate = new Date(startDatePicker.value);
                const endDate = new Date(endDatePicker.value);
                if (startDate > endDate) {
                    alert('Start date must be before end date.');
					startDatePicker.value = moment.utc(endDate).format('YYYY-MM-DD');
                    return;
                }
				startDate.setUTCDate(startDate.getUTCDate() - 1);
                endDate.setUTCDate(endDate.getUTCDate() - 1);
                startDatePicker.value = moment.utc(startDate).format('YYYY-MM-DD');
                endDatePicker.value = moment.utc(endDate).format('YYYY-MM-DD');
                loadTimelineDataInDateRange(startDate, endDate);
            });

            document.getElementById('nextDayBtn').addEventListener('click', () => {
                const startDate = new Date(startDatePicker.value);
                const endDate = new Date(endDatePicker.value);
                if (startDate > endDate) {
                    alert('Start date must be before end date.');
					startDatePicker.value = moment.utc(endDate).format('YYYY-MM-DD');
                    return;
                }
				startDate.setUTCDate(startDate.getUTCDate() + 1);
                endDate.setUTCDate(endDate.getUTCDate() + 1);
                startDatePicker.value = moment.utc(startDate).format('YYYY-MM-DD');
                endDatePicker.value = moment.utc(endDate).format('YYYY-MM-DD');
                loadTimelineDataInDateRange(startDate, endDate);
            });

            document.getElementById('goBtn').addEventListener('click', () => {
                const startDate = new Date(startDatePicker.value);
                const endDate = new Date(endDatePicker.value);
                if (startDate > endDate) {
                    alert('Start date must be before end date.');
					startDatePicker.value = moment.utc(endDate).format('YYYY-MM-DD');
                    return;
                }
				startDatePicker.value = moment.utc(startDate).format('YYYY-MM-DD');
                endDatePicker.value = moment.utc(endDate).format('YYYY-MM-DD');
                document.getElementById('loading-overlay').style.display = "flex";
				loadTimelineDataInDateRange(startDate, endDate);
				document.getElementById('loading-overlay').style.display = "none";

            });
        }

        function populateActivityFilters() {
            const activityFilters = document.getElementById('activityFilters');
            activityFilters.innerHTML = ''; // Clear existing filters

            const sortedActivityTypes = Array.from(activityTypes).sort();

            sortedActivityTypes.forEach(type => {
                const label = document.createElement('label');
                label.innerHTML = `
                <input type="checkbox" id="filter-${type}" class="layer-checkbox" checked> ${formatActivityType(type)}
            `;
                activityFilters.appendChild(label);

                // Add event listener to each filter checkbox
                const checkbox = document.getElementById(`filter-${type}`);
                checkbox.addEventListener('change', () => {
                    const startDate = new Date(document.getElementById('startDatePicker').value);
                    const endDate = new Date(document.getElementById('endDatePicker').value);
                    loadTimelineDataInDateRange(startDate, endDate);
                });
            });
        }

        function initLayerButton() {
            const layerBtn = document.getElementById('layerBtn');
            const layerOptions = document.getElementById('layerOptions');
            layerBtn.addEventListener('click', () => {
                layerOptions.style.display = layerOptions.style.display === 'none' ? 'block' : 'none';
            });

            // Add event listeners to layer visibility checkboxes
            document.getElementById('showVisits').addEventListener('change', () => {
                const startDate = new Date(document.getElementById('startDatePicker').value);
                const endDate = new Date(document.getElementById('endDatePicker').value);
                loadTimelineDataInDateRange(startDate, endDate);
            });
            document.getElementById('showActivities').addEventListener('change', () => {
                const startDate = new Date(document.getElementById('startDatePicker').value);
                const endDate = new Date(document.getElementById('endDatePicker').value);
                loadTimelineDataInDateRange(startDate, endDate);
            });
        }

        async function readFilesFromDirectory(dirHandle) {
			let timelineJsonFile = null;
			globalIndex = 0; // Reset global index

			document.getElementById('loading-overlay').style.display = "flex";

			// First, check for a single Timeline.json file
			for await (const entry of dirHandle.values()) {
				if (entry.kind === 'file' && entry.name === 'Timeline.json') {
					timelineJsonFile = entry;
					break;
				}
			}

			if (timelineJsonFile) {
				// If Timeline.json is found, load it directly
				try {
					const file = await timelineJsonFile.getFile();

					const content = await file.text();
					const data = JSON.parse(content);

					// Organize the data by year and month for compatibility with existing code
					const processedData = [];

					//Create array for the timelinePath points
					const processedTimelinePathObjects = [];

					// Check if it's the semantic segments format

					if (data.semanticSegments) {
						// Populate the timelinePath points from every timelinePath object
						data.semanticSegments.forEach(segment => {
							if (segment.timelinePath) {
								segment.timelinePath.forEach(point => {
									const tempPoint = {
										latE7: Math.round(parseFloat(point.point.split('¬∞,')[0]) * 1e7),
										lngE7: Math.round(parseFloat(point.point.split('¬∞,')[1]) * 1e7),
										time: point.time
									};
									processedTimelinePathObjects.push(tempPoint);
								});
							}
						});
						var timelinePathObjectsPointer = 0; // Define pointer for path points loop below
						const processedTimelineObjects = data.semanticSegments.map(segment => {
							if (segment.visit) {
								// Convert semantic segments visit to a similar format as the original timeline objects
								return {
									placeVisit: {
										location: {
											latitudeE7: Math.round(parseFloat(segment.visit.topCandidate.placeLocation.latLng.split('¬∞,')[0]) * 1e7),
											longitudeE7: Math.round(parseFloat(segment.visit.topCandidate.placeLocation.latLng.split('¬∞,')[1]) * 1e7),
											placeId: segment.visit.topCandidate.placeId,
											semanticType: segment.visit.topCandidate.semanticType,
											name: 'Unknown Location'
										},
										duration: {
											startTimestamp: segment.startTime,
											endTimestamp: segment.endTime
										}
									}
								};
							} else if (segment.activity) {
								// Define activitySegment properly here
								const activitySegment = {
									activityType: segment.activity.topCandidate.type || 'UNKNOWN',
									duration: {
										startTimestamp: segment.startTime,
										endTimestamp: segment.endTime
									},
									distance: segment.activity.distanceMeters,
									startLocation: {
										latitudeE7: Math.round(parseFloat(segment.activity.start.latLng.split('¬∞,')[0]) * 1e7),
										longitudeE7: Math.round(parseFloat(segment.activity.start.latLng.split('¬∞,')[1]) * 1e7)
									},
									endLocation: {
										latitudeE7: Math.round(parseFloat(segment.activity.end.latLng.split('¬∞,')[0]) * 1e7),
										longitudeE7: Math.round(parseFloat(segment.activity.end.latLng.split('¬∞,')[1]) * 1e7)
									},
									simplifiedRawPath: {
										distanceMeters: segment.activity.distanceMeters,
										points: []
									}
								};
								// Add simplified raw path if timelinePath exists
								// Find the associated timelinePath points for this activitySegment
								for (let i = timelinePathObjectsPointer; i < processedTimelinePathObjects.length; i++) {
									const point = processedTimelinePathObjects[i];

									if (point.time >= activitySegment.duration.startTimestamp && point.time <= activitySegment.duration.endTimestamp) {
										activitySegment.simplifiedRawPath.points.push(point)
									};
									if (point.time > activitySegment.duration.endTimestamp) {
										timelinePathObjectsPointer = i;
										break;
									}
								};
								return {
									activitySegment: activitySegment
								};
							}
						}).filter(Boolean); // Remove any undefined entries

						// Group by year and month
						processedTimelineObjects.forEach(item => {
							const timestamp = item.placeVisit ?
								item.placeVisit.duration.startTimestamp :
								item.activitySegment.duration.startTimestamp;
							const date = new Date(timestamp);
							const key = `${date.getFullYear()}_${date.toLocaleString('default', { month: 'long' }).toUpperCase()}`;

							if (!processedData[key]) {
								processedData[key] = {
									timelineObjects: []
								};
							}
							processedData[key].timelineObjects.push(item);

							// Collect unique activity types
							if (item.activitySegment) {
								activityTypes.add(item.activitySegment.activityType);
							}
						});

						timelineData = processedData;
					}
					// Fallback for original Google Takeout format
					else if (data.timelineObjects) {
						data.timelineObjects.forEach(item => {
							const timestamp = item.placeVisit ?
								item.placeVisit.duration.startTimestamp :
								item.activitySegment.duration.startTimestamp;
							const date = new Date(timestamp);
							const key = `${date.getFullYear()}_${date.toLocaleString('default', {
								month: 'long'
							}).toUpperCase()}`;

							if (!timelineData[key]) {
								timelineData[key] = {
									timelineObjects: []
								};
							}
							timelineData[key].timelineObjects.push(item);

							// Collect unique activity types
							if (item.activitySegment) {
								activityTypes.add(item.activitySegment.activityType);
							}
						});
					}

					console.log('Timeline.json loaded successfully');
				} catch (err) {
					console.error('Error parsing Timeline.json:', err);
				}
			} else {
				// Fallback to original method of reading multiple JSON files
				for await (const entry of dirHandle.values()) {
					if (entry.kind === 'file' && entry.name.endsWith('.json')) {
						const file = await entry.getFile();
						const content = await file.text();
						const data = JSON.parse(content);
						const fileName = entry.name.split('.')[0]; // Assuming filename format is synaptic_MONTH.json
						timelineData[fileName] = data;

						// Collect unique activity types from each file
						if (data.timelineObjects) {
							data.timelineObjects.forEach(item => {
								if (item.activitySegment) {
									activityTypes.add(item.activitySegment.activityType);
								}
							});
						}
					} else if (entry.kind === 'directory') {
						await readFilesFromDirectory(entry);
					}
				}
			}
			populateActivityFilters();
			document.getElementById('loading-overlay').style.display = "none";
		}

        async function initFolderPicker() {
            const folderPicker = document.getElementById('folderPicker');
            folderPicker.addEventListener('click', async () => {
                try {
                    const dirHandle = await window.showDirectoryPicker();
                    await readFilesFromDirectory(dirHandle);
                    console.log('Files loaded:', Object.keys(timelineData));
                    // Load data for the currently selected date range
                    const startDate = new Date(document.getElementById('startDatePicker').value);
                    const endDate = new Date(document.getElementById('endDatePicker').value);
                    loadTimelineDataInDateRange(startDate, endDate);
                } catch (err) {
                    console.error('Error selecting folder:', err);
                }
            });
        }

        window.onload = () => {
            initMap();
            initDatePicker();
            initFolderPicker();
            initLayerButton();
            const initialStartDate = new Date();
            const initialEndDate = new Date();
            document.getElementById('startDatePicker').value = moment(initialStartDate).format('YYYY-MM-DD');
            document.getElementById('endDatePicker').value = moment(initialEndDate).format('YYYY-MM-DD');

            // Add keyboard navigation
            document.addEventListener('keydown', async (e) => {
                if (e.key === 'ArrowLeft') {
                    document.getElementById("prevDayBtn").click();
                } else if (e.key === 'ArrowRight') {
                    document.getElementById("nextDayBtn").click();
                }
            });
        };
    </script>
</body>

</html>
